<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/my-note/blog/rss.xml" title="YumeMemooo's Note Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/my-note/blog/atom.xml" title="YumeMemooo's Note Blog Atom Feed"><title data-react-helmet="true">[go] Gorountine | YumeMemooo&#x27;s Note</title><meta data-react-helmet="true" property="og:url" content="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="[go] Gorountine | YumeMemooo&#x27;s Note"><meta data-react-helmet="true" name="description" content="一種golang的協程？"><meta data-react-helmet="true" property="og:description" content="一種golang的協程？"><link data-react-helmet="true" rel="shortcut icon" href="/my-note/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine"><link data-react-helmet="true" rel="alternate" href="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine" hreflang="x-default"><link rel="stylesheet" href="/my-note/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/my-note/assets/js/runtime~main.6c659791.js" as="script">
<link rel="preload" href="/my-note/assets/js/main.216c6d34.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><div class="announcementBar_3WsW" style="background-color:#82e675;color:#050505" role="banner"><div class="announcementBarContent_3EUC">☞這裡是暫存的隨筆草稿區，另有建立整理後的文章可以進入☆主網站 <a target="_blank" rel="noopener noreferrer" href="https://yumememooo.github.io/" ☆> yumememooo</a>☆</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-note/"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">YumeMemooo&#x27;s Note</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/my-note/docs/intro">All Notes</a><a class="navbar__item navbar__link" href="/my-note/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">My Github</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link">Community</a><ul class="dropdown__menu"><li><a href="https://yumememooo.github.io/about/" target="_blank" rel="noopener noreferrer" class="dropdown__link">About Me</a></li><li><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="dropdown__link">GitHub</a></li></ul></div><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/my-note/"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">YumeMemooo&#x27;s Note</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/my-note/docs/intro">All Notes</a></li><li class="menu__list-item"><a class="menu__link" href="/my-note/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="menu__link">My Github</a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">Community</a><ul class="menu__list"><li class="menu__list-item"><a href="https://yumememooo.github.io/about/" target="_blank" rel="noopener noreferrer" class="menu__link">About Me</a></li><li class="menu__list-item"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/my-note/docs/intro">關於 YumeMemooo&#x27;s Note</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Docusaurus</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/intro">Tutorial Intro</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Tutorial - Basics</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/create-a-page">Create a Page</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/create-a-document">Create a Document</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/create-a-blog-post">Create a Blog Post</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/markdown-features">Markdown Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/deploy-your-site">Deploy your site</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/congratulations">Congratulations!</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Tutorial - Extras</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-extras/manage-docs-versions">Manage Docs Versions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-extras/translate-your-site">Translate your site</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">frontend</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">desing</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/design/design_pixel">像素與解析度</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">all</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/all/http-cors">[web] 跨域請求 CORS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/all/react-hook-learn">網路文章 react hook系列文學習筆記</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">best_pratice</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/best_pratice/google">Google I/O 2021 </a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/best_pratice/html_a_ref">[安全性]為什麼超連結要使用noreferrer noopener</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/best_pratice/js">JS更好的寫法</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">backend</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">golang</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_ why">golang介紹與優勢</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_ little_thing">golang的那些小事</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_ asleep">all goroutines are asleep</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_Continuous Profiling">[go] Continuous Profiling</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/my-note/docs/backend/golang/go_Gorountine">Gorountine</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_chan">[go] channel</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_map">GOLANG的MAP的併發問題</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_pprof">[go] pprof</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_struct">[go] struct &amp; tag</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_switch">[go] switch</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_trace">[go] trace</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">others</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/backend/others/linux_command">[command]linux 歷史紀錄</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/backend/others/number_bit">位元與數字</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/backend/others/startedTime">程式的啟動速度</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">tool</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/git">[node]npx</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/node">[git] 上傳程式碼操作</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/open_ material">[material] 網路上素材與線上工具</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/github">github</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/mac">mac</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><p>一種golang的協程？</p><blockquote><p>以下為個人學習上節錄網路資訊,皆有附上原文連結,可以點入原文看更多細節</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多執行緒"></a>多執行緒<a class="hash-link" href="#多執行緒" title="Direct link to heading">#</a></h2><ul><li>[電腦的核心 (Core) 和執行緒 (Tread)](<a href="https://jenifers001d.github.io/2020/08/04/%E9%9B%BB%E8%85%A6%E7%9F%A5%E8%AD%98/what-is-core-and-thread/" target="_blank" rel="noopener noreferrer">https://jenifers001d.github.io/2020/08/04/%E9%9B%BB%E8%85%A6%E7%9F%A5%E8%AD%98/what-is-core-and-thread/</a></li><li>淺談多核CPU、多執行緒與平行計算](<a href="https://www.itread01.com/content/1549608874.html" target="_blank" rel="noopener noreferrer">https://www.itread01.com/content/1549608874.html</a><ul><li>多執行緒的作用不只是用作平行計算</li><li>阻塞在什麼時候發生呢？一般是等待IO操作（磁碟，資料庫，網路等等）。</li><li>在單核時代，多執行緒的這個消除阻塞的作用還可以叫做“併發”，這和並行是有著本質的不同的。併發是“偽並行”，看似並行，而實際上還是一個CPU在執行一切事物，只是切換的太快，我們沒法察覺罷了。</li><li>四種場景？？不懂</li></ul></li><li><a href="https://www.itread01.com/content/1544961004.html" target="_blank" rel="noopener noreferrer">對於多執行緒程式，單核cpu與多核cpu是怎麼工作的</a><ul><li>多執行緒在單cpu中其實也是順序執行的，，不過系統可以幫你切換那個執行而已，效率不會有提高的≤切換執行緒反倒會增加開銷</li><li><code>多執行緒的用處在於，做某個耗時的操作時，需要等待返回結果，這時用多執行緒可以提高程式併發程度</code>。如果一個不需要任何等待並且順序執行能夠完成的任務，用多執行緒簡直是浪費。</li><li>什麼時候該使用多執行緒呢？這要分四種情況討論：？？不懂</li></ul></li><li><a href="https://medium.com/erens-tech-book/%E7%90%86%E8%A7%A3-process-thread-94a40721b492" target="_blank" rel="noopener noreferrer">【恐龍】理解 Process &amp; Thread</a><ul><li>併發不一定要在同一時刻？並發未必平行</li></ul></li><li><a href="https://www.gushiciku.cn/pl/pcJA/zh-tw" target="_blank" rel="noopener noreferrer">15分鐘讀懂程序執行緒、同步非同步、阻塞非阻塞、併發並行，太實用了！</a><ul><li>多執行緒：火車站開n個視窗</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="併發與平行"></a>併發與平行<a class="hash-link" href="#併發與平行" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10242047" target="_blank" rel="noopener noreferrer">ＩＴ邦 程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a></p><ul><li>程arallel 並行是利用多個 CPU 達到同時並行處理任務的需求（也就是同一個時間點有許多任務在同時執行）</li><li>Concurrent 則是許多任務在爭搶同一個 CPU 的資源，因此一個時間點只會有一個任務正在執行，只是因為切換非常快，使用者通常不會感覺到任務實際上一直在切換。 (單核是，但多核怪怪的 併發不一定要在同一時刻？並發未必平行)
<img src="https://miro.medium.com/max/1108/1*7GZrAWoGc_nZtuvHIJ9w-w.jpeg"></li></ul></li><li><p><a href="https://hsinyu.gitbooks.io/golang_note/content/goroutine.html" target="_blank" rel="noopener noreferrer">goroutine個人筆記 concurrency (併發) vs parallelism (並行)</a>覺得process圖這篇怪怪的</p><ul><li><code>M:N圖</code></li></ul></li><li><p><a href="https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism" target="_blank" rel="noopener noreferrer">Concurrency-vs-Parallelism</a> </p><ul><li>這圖畫得比較好</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="線程與協程"></a>線程與協程<a class="hash-link" href="#線程與協程" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10242047" target="_blank" rel="noopener noreferrer">ＩＴ邦 程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a></p><ul><li>MultiProcessing 多進程 &amp; MultiThreadingf 多線程</li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10239629" target="_blank" rel="noopener noreferrer">Day 18 | Kotlin 中處理異步的好伙伴 - Coroutine</a></p><ul><li>程式（Application ）&gt;進程（ Process ）&gt;線程/執行緒（ Thread ) &gt;協程（ Coroutine ） </li><li>Process 之間是不能直接溝通的（如果可以任意呼叫到其他應用程式裏面的內容，那也有點太可怕了）</li><li>Thread 共享資源</li><li>協程（ Coroutine ） ： Coroutine 一次只會執行一個 Job ，會透過頻繁切換 Job 達到類似異步的效果，需要的資源比開新的 Thread 少  <code>圖</code></li></ul></li></ul><ul><li><a href="https://ithelp.ithome.com.tw/articles/10219673" target="_blank" rel="noopener noreferrer">30-08 之應用層的 I/O 優化 ( 維護性 ) - 協程 Coroutine</a><ul><li>coroutine 協程:在應用層實現同步非阻塞的 I/O 操作</li><li>異步非阻塞寫法:callback hell-&gt;同步非阻塞寫法(在 nodejs 中的 async/await 就是協程)</li><li>coroutine 協程實現原理:應用端內部會『 自行 』的決定誰先執行</li><li>關於 Coroutine 的幾個問題:coroutine是性能的減項,此應用已是一個異步非阻塞的應用，當你搭配 coroutine 下去，會減少不少的維護成本，因為寫法就和一般程式寫法一樣。</li><li><code>Golang 的 Goroutine?-&gt; 是coroutine嗎？</code>一半算，goroutine 有實現 corotuine 想完成的『同步』這個事情，但同時間它又針對 cpu 運算這方面在實現上增加不少改善</li><li>Golang 的運行架構:Sched+MPG 模型,goroutine 在運行時阻塞了會自動的分配到閒的 thread <code>有調度解說</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="非阻塞-io-模型-reactor"></a>非阻塞 I/O 模型 Reactor<a class="hash-link" href="#非阻塞-io-模型-reactor" title="Direct link to heading">#</a></h3><ul><li><a href="https://ithelp.ithome.com.tw/articles/10219203" target="_blank" rel="noopener noreferrer">30-07 之應用層的 I/O 優化 - 非阻塞 I/O 模型 Reactor</a>
當系統 I/O 操作繁重時，請使用 refactor 模式的支援語言或是框架。
當系統 CPU 運算繁重時，則使用 multi process 的模式。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goroutine-是coroutine嗎？"></a>Goroutine 是coroutine嗎？<a class="hash-link" href="#goroutine-是coroutine嗎？" title="Direct link to heading">#</a></h2><ul><li>上面說一半算</li><li><a href="http://c.biancheng.net/view/96.html" target="_blank" rel="noopener noreferrer">goroutine和coroutine的区别</a><ul><li><code>goroutine 可能发生并行执行</code>；但 coroutine 始终顺序执行。</li><li>goroutines 通过通道来通信；coroutines 通过让出和恢复操作来通信 (goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。)</li><li>goroutines 比 coroutines 更强大</li><li>goroutine 可能发生在多线程环境下，goroutine 无法控制自己获取高优先度支持；coroutine 始终发生在单线程，coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine。</li><li>coroutine 的运行机制属于协作式任务处理，如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力</li><li>goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</li></ul></li><li><a href="https://stackoverflow.com/questions/18058164/is-a-go-goroutine-a-coroutine" target="_blank" rel="noopener noreferrer">Go goroutine 是協程嗎？stackoverflow</a></li><li><a href="https://www.huaweicloud.com/articles/949bec4beeb84dfcaea30513b3d497c8.html" target="_blank" rel="noopener noreferrer">python协程与golang协程精讲</a><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- Python的协程源于yield指令</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- Go实现了两种并发形式:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    - 多线程共享内存。如Java或者C++等在多线程中共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    - Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。Go的CSP并发模型实现M, P, G : </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- go的协程本质上还是系统的线程调用，而Python中的协程是eventloop模型实现，所以虽然都叫协程,Python 中的协程是严格的 1:N 关系一个线程对应了多个协程。虽然可以实现异步I/O，但是不能有效利用多核</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- 而 Go 中是 M:N 的关系也就是 N 个协程会映射分配到 M 个线程上多个线程能分配到不同核心上,CPU 密集的应用使用 goroutine 也会获得加速.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div>即使有少量阻塞的操作，也只会阻塞某个 worker 线程，而不会把整个程序阻塞<div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- goroutine 中不需要显式使用 await 交出控制权，但是 Go 也不会严格按照时间片去调度 goroutine，而是会在可能阻塞的地方插入调度。goroutine 的调度可以看做是半抢占式的。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="coroutine"></a>Coroutine<a class="hash-link" href="#coroutine" title="Direct link to heading">#</a></h2><p>這邊是講傳統的協程用法 yield</p><ul><li><a href="https://electronic.blue/blog/2012/06/11-coroutine-an-introduction/" target="_blank" rel="noopener noreferrer">Coroutine: 入門篇</a></li><li><a href="https://mp.weixin.qq.com/s/6sN2hdxCNWiDfizWdzS2yA" target="_blank" rel="noopener noreferrer">如何编写 C++ 20 协程(Coroutines)</a><ul><li>C++协程就是一个可以挂起(suspend)和恢复(resume)的函数(</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="所以？？"></a>所以？？<a class="hash-link" href="#所以？？" title="Direct link to heading">#</a></h3><ul><li><p><a href="https://codychen.me/2019/12/%E5%A4%9A%E9%80%B2%E7%A8%8B/%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92-%E4%B8%A6%E7%99%BC/%E5%B9%B3%E8%A1%8C/" target="_blank" rel="noopener noreferrer">多進程/多執行緒！ 並發/平行？</a> 看完更不懂了</p></li><li><p>Ｑ多核多執行緒是否就是平行處理？</p></li><li><p>Ｑ：多核下的併發是否可以是一些平行處理一些併發處理？？</p><ul><li>這兩個問題在IT 邦幫忙有得到解答：）<a href="https://ithelp.ithome.com.tw/articles/10218483" target="_blank" rel="noopener noreferrer">https://ithelp.ithome.com.tw/articles/10218483</a></li></ul></li><li><p><a href="https://www.gushiciku.cn/pl/2P2w/zh-tw" target="_blank" rel="noopener noreferrer">Go FAQ 問題</a></p></li></ul><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="影1-线程和协程的区别"></a>影1 线程和协程的区别<a class="hash-link" href="#影1-线程和协程的区别" title="Direct link to heading">#</a></h2><p>1.（影）为什么golang能够脱颖而出？线程和协程的区别是什么？</p><p>1.1 線程是跟硬件相關的 會消耗佔用ＣＰＵ 內存等等
線程是軟件的概念 像是函數 method？ 類似是消息的隊列</p><p>1.2 創建goruntine的開銷是比較小的 速度也快很多
可以創建一百萬兩百萬的協程沒有問題
但就做不到創建一百萬兩百萬個線程了 慢且ＣＰＵ沒有這麼多core，內存被消耗得很厲害</p><p>1.3 線程都有一個唯一的ＩＤ來標示，“Goroutine沒有？”</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="延伸閱讀：為什麼沒有goroutine-id"></a>延伸閱讀：為什麼沒有Goroutine ID<a class="hash-link" href="#延伸閱讀：為什麼沒有goroutine-id" title="Direct link to heading">#</a></h4><ul><li><a href="https://www.gushiciku.cn/pl/gYQQ/zh-hk" target="_blank" rel="noopener noreferrer">Go 羣友提問：進程、線程都有 ID，為什麼 Goroutine 沒有 ID？</a></li><li>在常規的進程、線程中都有其 ID 的概念，我們可以在程序中通過 ID 來獲取其他進程、線程中的數據，甚至是傳輸數據。就像一把鑰匙一樣，有了他幹啥都可以。</li><li>Go 語言在以前是有暴露方法去獲取 GoroutineID 的，但在 Go1.4 後就把該方法給隱藏起來了，不建議大家使用。假設可以通過 GoroutineID 進行跨協程操縱，那麼就有可能出現我的 Goroutine，不一定是由 “我” 自己決定的。可能其他正在處理的 GoroutineB 悄悄摸摸的改了我這個 GoroutineA 的行為。
這就有可能導致一個災難問題</li><li>其實還是可以寫程式去拿到Goroutine ID的，而去排查 Go 工程中的問題，例如：錯誤堆棧信息、PProf 性能分析等調試信息也可以看到。</li></ul><p>1.4 通信方式
線程適用全局變量還要加鎖保證數據沒有,,,？？？
協程使用channel </p><hr><p>看起來同步的方式去寫出異步 非阻塞式掛起</p><hr><p><code>不太懂</code></p><p><a href="https://www.youtube.com/watch?v=uJXSMMyvAgM" target="_blank" rel="noopener noreferrer">沈崴 - 为什么协程是真并行而线程不是</a>
攜程也是可以多核
協程可以控制上下文 把邏輯切換點作為調度點?
協程是真並行?</p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goroutine入门"></a>goroutine入门<a class="hash-link" href="#goroutine入门" title="Direct link to heading">#</a></h2><ul><li><a href="https://www.cnblogs.com/sparkdev/p/10930168.html" target="_blank" rel="noopener noreferrer">Golang 入门 : goroutine(协程)</a><ul><li>要在一个协程中运行函数，直接在调用函数时添加关键字 go 就可以了</li><li>协程也叫轻量级的线程，与传统的进程和线程相比，协程的最大特点是 &quot;轻&quot;！可以轻松创建上百万个协程而不会导致系统资源衰竭。</li><li>多数编程语言在语法层面并不直接支持协程，而是通过库的方式支持。但是用库的方式支持的功能往往不是很完整，比如仅仅提供轻量级线程的创建、销毁和切换等能力。如果在这样的协程中调用一个同步 IO 操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行的协程，从而无法达到轻量级线程本身期望达到的目标。</li><li>Golang 在语言级别支持协程，称之为 goroutine。Golang 标准库提供的所有系统调用操作(包括所有的同步 IO 操作)，都会出让 CPU 给其他 goroutine。这让 goroutine 的切换管理不依赖于系统的线程和进程，也不依赖于 CPU 的核心数量，而是交给 Golang 的运行时统一调度。</li></ul></li><li><a href="https://www.educative.io/edpresso/what-are-channels-in-golang" target="_blank" rel="noopener noreferrer">What are channels in Golang?</a>     <code>可愛的通道圖</code></li><li><a href="https://zhuanlan.zhihu.com/p/74047342" target="_blank" rel="noopener noreferrer">Golang协程详解和应用</a><ul><li>并发还并行? 程式碼</li><li>如果当前CPU是单核，那么上面程序就是并发执行，如果当前CPU是多核，那就是并行执行，结果都是一样的-&gt;说明单核CPU只能并发，不能并行</li></ul></li></ul><p>demoe:<a href="https://play.golang.org/p/ZR_Y6ugAgfW" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/ZR_Y6ugAgfW</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="channel-介紹"></a>channel 介紹<a class="hash-link" href="#channel-介紹" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10241501" target="_blank" rel="noopener noreferrer"># Day15 給我Go通道- Golang Channel (Block vs Deadlock)</a> it幫幫忙</p><ul><li>Unbuffered 是需要有同時有 一頭寫入、另一頭讀出</li><li>讀寫速率要控制在一定的範圍內，Channel中的緩衝區塊才能起到作用。
若寫入通道中的速度永遠大於寫入速度（塞娃娃的速度永遠比用娃娃來的快），那麼給再多再大的倉庫放，永遠都會有不夠放的一天。</li><li>但是若是實作上真的有需求，可以透過一些trick的手段達成、模擬無限通道這件事 ？？？ＴＢＤ，
例如使用 slice 來記錄通道中的東西。</li></ul></li><li><p><a href="https://pjchender.dev/golang/goroutine-channels-concurrency/" target="_blank" rel="noopener noreferrer">pjchender [Golang] goroutines, channels, and concurrency</a></p><ul><li>可宣告單一通道@@ unidirectional channels <code>TBD</code></li><li>當 channel 本身就有值時，就不會走到 default，但如果 channel 執行的當下沒有值，還需要等其他 goroutine 設值到 channel 的話，就會直接走到 default</li><li>worker pool 指的是有許多的 goroutines 同步的進行一個工作。要建立 worker pool，會先建立許多的 worker goroutine</li></ul></li><li><p><a href="https://blog.csdn.net/QiuHaoqian/article/details/113103478" target="_blank" rel="noopener noreferrer">Go channel的使用场景与注意项</a></p><ul><li>信号通知 数据传递 </li><li>生产消费模型 控制并发数</li><li>执行任务超时</li><li>自定义互斥锁</li><li>注意channel 的哪些操作会引发 panic？只有提到關閉等發送問題</li></ul></li><li><p><a href="https://segmentfault.com/a/1190000017537297" target="_blank" rel="noopener noreferrer">使用Select实现无阻塞读写</a></p><ul><li>无论是有缓存通道、无缓冲通道都存在阻塞的情况。</li><li>示例代码是使用select修改后的无缓冲通道和有缓冲通道的读写,select+defalut</li><li>使用Select+超时改善无阻塞读写,使用定时器替代default可以解决这个问题，给通道增加读写数据的容忍时间</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="issue"></a>issue<a class="hash-link" href="#issue" title="Direct link to heading">#</a></h3><ul><li><a href="https://ithelp.ithome.com.tw/articles/10218923" target="_blank" rel="noopener noreferrer">IT邦幫忙發問</a><ul><li>設計錯誤 來源端應該限流設計 <code>TBD</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="data-race"></a>data race<a class="hash-link" href="#data-race" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://segmentfault.com/a/1190000018719287" target="_blank" rel="noopener noreferrer">15 Go语言并发1——Goroutine</a></p><ul><li>Go 調度器</li><li>简单使用waitgroup同步</li><li>如何解决资源竞争和线程同步，这就有两类，一类是传统的方式——加锁，另一类是go语言有的通过chanel,采用<code>csp模型，即通过通信去共享内存，而不是通过共享内存而通信。</code></li><li><code>原子函数atomic</code> 然可以解决资源竞争问题，但是比较都是比较简单的，支持的数据类型也有限。所以，sync 提供了互斥锁来解决</li><li>sync包里提供了一种互斥型的锁，可以让我们自己灵活的控制哪些代码，同时只能有一个goroutine访问，被sync互斥锁控制的这段代码范围，被称之为临界区，临界区的代码，同一时间，只能有一个goroutine访问。代码如下</li><li><code>读写锁</code>:goroutine进行写操作的时候，其他goroutine既不能进行读操作，也不能进行写操作。</li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10239243" target="_blank" rel="noopener noreferrer">Day10 Race Condition</a></p><ul><li>race condition(或稱data race)  提到用channel與鎖做相加，有圖有程式碼,下一篇有效能對比</li></ul></li><li><p><a href="https://clouding.city/go/mutex-rwmutex/" target="_blank" rel="noopener noreferrer">Go 簡單例子來理解 sync.Mutex 和 sync.RWMutex</a></p><ul><li>用讀寫鎖效能更好 有程式碼範例</li></ul></li><li><p><a href="https://mozillazg.com/2019/04/notes-about-go-lock-mutex.html" target="_blank" rel="noopener noreferrer">Go: 关于锁（mutex）的一些使用注意事项</a></p><ul><li>尽量减少锁的持有时间 善用defer</li><li>copy 结构体操作可能导致非预期的死锁 使用 go vet 工具检查代码中锁的使用问题 ??? <code>TBD</code></li><li>build/test 时使用 -race 参数以便运行时检测数据竞争问题</li><li>使用 go-deadlock 检测死锁或锁等待问题<code>TBD</code></li><li>实现 tryLock 功能:一般 Lock() 如果拿不到锁的话，会一直阻塞在那里</li><li>改为使用 channel:有些时候可能使用 channel 会更符合需求，合适的场景选择合适的方法即可，既不需要畏惧 channel 也不必畏惧 lock 。<ul><li>（可以参考 <a href="https://blog.golang.org/codelab-share" target="_blank" rel="noopener noreferrer">Share Memory By Communicating - The Go Blog</a> 这篇文章）<code>TBD</code></li></ul></li></ul></li><li><p><a href="https://chende.ren/2020/12/28140907-009-concurrency.html" target="_blank" rel="noopener noreferrer">闪电侠的小黑板</a></p><ul><li>資料競爭的三種處理 圖 </li><li>原子操作 互斥鎖 ｃｈａｎｎｅｌ 介紹與程式碼</li></ul></li><li><p><a href="https://larrylu.blog/race-condition-in-golang-c49a6e242259" target="_blank" rel="noopener noreferrer">用一個小例子談談 Golang 中的 Race Condition</a></p><ul><li>透過 Race Detector 幾乎可以找到所有的 race condition，大部分時候也都只要加個鎖就可以解決</li><li>鎖的缺點 不如用個迴圈把它從 0 加到 10000 可能還更快?</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="岩生"></a>岩生<a class="hash-link" href="#岩生" title="Direct link to heading">#</a></h3><ul><li><p>别混淆数据争用(data race) 和竞态条件(race condition)
<a href="https://blog.csdn.net/gg_18826075157/article/details/72582939" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/gg_18826075157/article/details/72582939</a> ？？看不懂</p></li><li><p>Golang Taipei Gathering 分享 - Golang Race Detector under the hood
<a href="https://kkc.github.io/2021/06/29/golang-race-detector/" target="_blank" rel="noopener noreferrer">https://kkc.github.io/2021/06/29/golang-race-detector/</a>
裡面的程式沒有 Data race，但是有 Race condition</p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="thread-safety"></a>Thread-Safety<a class="hash-link" href="#thread-safety" title="Direct link to heading">#</a></h4><p>-<a href="https://ithelp.ithome.com.tw/articles/10229824?sc=rss.qu" target="_blank" rel="noopener noreferrer">[Java] Thread-Safety是什麼 – Part 2</a></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- 在同一時間只有一個thread能存取synchronized method。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><blockquote><p>執行緒安全 (Thread-safe)
現代程式設計為了提升效能，通常採用多執行緒的方式執行，但若沒有注意執行緒安全，往往會造成意想不到的錯誤。</p><ul><li>查詢發現 JAVA也有讀寫鎖</li><li><a href="https://www.gss.com.tw/blog/java-concurrency-2-thread-safety" target="_blank" rel="noopener noreferrer">Java Concurrency #2 - Thread Safety</a><ul><li>Race condition 就是某個運算的結果要看運氣才會正確，而且是因為多個 Thread 因為時間差或 相互交織(interleave) 造成的，就可以這麼稱呼這個現象</li></ul></li></ul></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="go-worker-pool"></a>Go Worker Pool<a class="hash-link" href="#go-worker-pool" title="Direct link to heading">#</a></h3><p>有一種寫法是可以開多個消費接收端進行處理，<code>但效能如何看？？ TBD</code> </p><ul><li><a href="https://gobyexample.com/worker-pools" target="_blank" rel="noopener noreferrer">Go by Example: Worker Pools</a></li><li><a href="https://www.coder.work/article/1027330" target="_blank" rel="noopener noreferrer">concurrency - Go Worker Pool似乎没有同时处理</a></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="關於到底什麼時候用鎖-go-鎖與channel選用？？"></a>關於到底什麼時候用鎖 go 鎖與channel選用??？？<a class="hash-link" href="#關於到底什麼時候用鎖-go-鎖與channel選用？？" title="Direct link to heading">#</a></h3><ul><li><p><a href="https://www.zhihu.com/question/27596075" target="_blank" rel="noopener noreferrer">如何理解“Do not communicate by sharing memory; instead, share memory by communicating.”？</a></p><ul><li>communicate by sharing memory需要考虑加锁避免race condition,加锁又会提高开发及调试难度。而 share memory by communicating则可以将对共享资源(memory)的访问串行化，于是就不用考虑race condition了。后者有点像UI编程的消息驱动模型。</li><li>其实这两种模式在Go语言都有很好的支持，所以我觉得这句话可以理解为宣传channel之优雅的一句口号而已，实际使用时还是应该具体问题具体分析。</li></ul></li><li><p><a href="https://www.jianshu.com/p/039732010f1c" target="_blank" rel="noopener noreferrer">golang 互斥锁的两种实现</a></p><ul><li>channel 本质上是一个MessageQueue，主要用于协程之间消息的传递，虽然也可以拿来当互斥锁（但是正常还是应该让mutex做）</li><li>channel成本更高，channel内部有Mutex.....从这里我们可以看出channel 里面不只有互斥锁,大柴小用</li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10239933" target="_blank" rel="noopener noreferrer">IT邦幫忙 Day11 Mutex vs Channel</a></p><ul><li>Benchmark: 一般情況下，如果我們只是想避免變數上的污染，大可放心的使用較簡易的 mutex lock。畢竟他效能佳且使用較為直覺</li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/questions/10204745" target="_blank" rel="noopener noreferrer">IT邦幫忙發問 [golang] 使用channel與鎖遇到狀況的選用？</a></p></li><li><p><a href="https://blog.csdn.net/windows_2015/article/details/108695948" target="_blank" rel="noopener noreferrer">Go语言并发--传统锁与channel的选择</a></p><ul><li>有確認流程圖 但我看不懂<code>TBD</code></li></ul></li></ul><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="推薦-it邦幫忙教學文"></a>推薦 IT邦幫忙教學文<a class="hash-link" href="#推薦-it邦幫忙教學文" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10240892" target="_blank" rel="noopener noreferrer"># Day14 Go併發症狀- Goroutines (go)</a></p><ul><li>併發(Concurrency)是共享時間運算，在一段時間內輪流享有時間資源 ，是把時間切成很小很小段，在這小段的時間裡先後執行多項任務。一個人在一段時間內做兩件事</li><li>併行(Parallelism)是平行運算，一直都能享有時間資源,是CPU有多個核心，可以同時處理多個任務。,兩個人同時在做事</li><li>Go併發（Goroutines）是輕量級的線程。</li><li>入門使用及限制一個ＣＰＵ核心runtime.GOMAXPROCS(1)時, Goroutine 仍可以切換．</li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10212068?sc=pt" target="_blank" rel="noopener noreferrer">Go 的並發：Goroutine 與 Channel 介紹</a></p><ul><li>介紹單執行緒與多執行緒下Goroutine 的圖示</li><li>互斥與channel</li><li><code>TBD Q</code></li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10218923" target="_blank" rel="noopener noreferrer">Channel, goroutine之間的溝通橋樑</a></p><ul><li>Channel就像是一個輸送帶, 遵守著FIFO的規則, 保證收發資料的順序.</li><li>多個goroutine為了搶奪存取資料, 勢必造成執行效率的低下, 使用queue是一種高效率的同步存取方式, channel就是一種queue一樣的結構.</li><li>channel 宣告介紹 ＋ <code>緩衝與無緩衝 圖</code>·</li><li>發送資料量必須在消費方處理量+通道長度的範圍內, 才能正確的處理</li><li>不要透過共享變數+Mutex來進行操作, 應該透過channel來共享</li><li>對channel的操作行為整理 close slect&amp; 發布端跟訂閱端這裡的使用場景....</li><li><code>TBD Q</code></li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10218483" target="_blank" rel="noopener noreferrer">Goroutine 讓你用少少的線程, 能接受更多的工作, 但沒說會作比較快</a></p><ul><li>一個goroutine大小大概2kb-4kb, 非常的小, 所以要管理個上千上萬個goroutine是相對於其他語言, 比較不佔記憶體的.</li><li>Go的併發同步模型是採用CSP(Communicating Sequential Process), 是一種訊息傳遞模式, 不是透過對資料加上lock來做同步存取, 而是透過CSP在goroutine之間傳遞訊息, channel在多個goroutine之間進行同步通信與交換.</li><li>單核的情形下, Goroutine跟 NodeJS的EventLoop(1:m映射)很相似.</li><li>多核心多線程, goroutine會生成多個邏輯處理器在調度器間處理, 每個上會有很多goroutines (n:m映射). </li><li>Concurrency 圖 滿足Go跟Node的設計哲學, &quot;用較少的資源作更多的事情&quot;. ＋ Parallelism goroutine在不同的系統線程M上執行.但如果要實現平行, 需要自己讓代碼執行在有多個物理cpu上. （<code>重要</code>）</li><li><code>TBD Q</code></li></ul></li></ul><ul><li>[Day09] 進程、線程、協程，傻傻分得清楚！](<a href="https://ithelp.ithome.com.tw/articles/10242047" target="_blank" rel="noopener noreferrer">https://ithelp.ithome.com.tw/articles/10242047</a>)<ul><li><code>圖 Concurrent &amp; Parallel + 圖  進程、線程、協程</code></li><li>名詞對照</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goroutine-調度模型"></a>goroutine 調度模型<a class="hash-link" href="#goroutine-調度模型" title="Direct link to heading">#</a></h2><ul><li><a href="https://www.readfog.com/a/1634446830986170368" target="_blank" rel="noopener noreferrer">探究 goroutine 併發調度模型</a><ul><li>官方宣稱原生 goroutine 併發成千上萬不成問題。實現併發編程，goroutine 具有消耗資源低、運行效率高等特點</li><li>Go 調度器需要將衆多 goroutine 按照一定的算法調度到操作系統的線程上執行。這種在語言層面自帶調度器的，稱之爲原生支持併發。</li><li>操作系統會爲每個線程分配固定大小（一般是 2MB）的內存塊做棧。線程在內核切換上下文是很慢的。</li><li><code>動態棧</code>:goroutine 的棧不是固定的，一開始以一個很小的棧空間（2KB）開啓生命週期，棧的大小會根據需要動態伸縮。</li><li><code>調度器的切換成本</code>Go 調度器是在其本身運行的用戶層進行調度的，不需要進入內核的上下文切換，調度成本會低很多。</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/60613088" target="_blank" rel="noopener noreferrer">Go goroutine理解</a><ul><li>Goroutine和其他语言的协程（coroutine）在使用方式上类似， 因此Goroutine可以理解为一种Go语言的协程。同时它可以运行在一个或多个线程上。</li><li>Go实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是Java或者C++等语言中的多线程开发。另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</li><li>GO并发模型的实现原理 <code>TBD hard</code>  M:N的圖</li><li>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（goroutine：2KB ，线程：8MB）</li><li>Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。缺点：协程调度机制无法实现公平调度。</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/80853548" target="_blank" rel="noopener noreferrer">深度解密Go语言之 scheduler</a><ul><li><code>M:N 模型</code>:Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。这就是 M:N 模型：向一个 channel 发送数据，被阻塞）时，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。目的就是不让一个线程闲着，榨干 CPU 的每一滴油水。</li><li>限制同时运行（不包含阻塞）的线程数为 N，N 等于 CPU 的核心数目；</li><li>scheduler 的陷阱:于 Go 语言中运行时间过长的 goroutine，Go scheduler 有一个后台线程在持续监控，一旦发现 goroutine 运行超过 10 ms，会设置 goroutine 的“抢占标志位”</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="可以用開的goroutines數量"></a>可以用開的goroutines數量<a class="hash-link" href="#可以用開的goroutines數量" title="Direct link to heading">#</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/162668146" target="_blank" rel="noopener noreferrer">为什么 Go 允许百万级别的 goroutines，而 Java 只允许数千级别的 threads?</a><ul><li><code>Thread</code> CPUs 中的每一个 Core 在同一时刻只能真正并发执行一个 logic thread[1]。这就产生了一个结论：如果你的 threads 个数大于 CPU 的 Core 个数的话，有一部分的 Threads 就必须要暂停来让其他 Threads 工作，</li><li>使用操作系统层面的 thread，每一个 thread 都需要耗费静态的大量的内存,果使用1MB的栈默认值，那么创建1000个 threads ，将使用 1GB 的 RAM ，虽然 RAM 现在很便宜，但是如果要创建一亿个 threads ，就需要T级别的内存。</li><li>新建的一个 Goroutine 实际只占用 4KB 的栈空间。一个栈只占用 4KB，1GB 的内存可以创建 250 万个 Goroutine，相对于 Java 一个栈占用 1MB 的内存，这的确是一个很大的提高。</li><li>在 JVM 中上下文的切换是很慢的<ul><li>评论: go的百万goroutine调度慢到吓人，内存占用也高到恐怖.而真正实现百万级调度还基本可用的是C#的task</li><li>为啥C#支持无上限的协程，而Go只支持百万级？一个脑子正常的java程序员不可能开上千个thread</li></ul></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="go-doc"></a>Go DOC<a class="hash-link" href="#go-doc" title="Direct link to heading">#</a></h2><ul><li>effective_go](<a href="https://golang.org/doc/effective_go" target="_blank" rel="noopener noreferrer">https://golang.org/doc/effective_go</a>)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="effective_go"></a>effective_go<a class="hash-link" href="#effective_go" title="Direct link to heading">#</a></h3><p>高效的 Go 编程 中文翻譯</p><ul><li><a href="https://learnku.com/docs/effective-go/2020/concurrent/6249" target="_blank" rel="noopener noreferrer">高效的 Go 编程</a><ul><li>併發<ul><li><code>Share by communicating</code>:不要通過共享內存來通信，而應通過通信來共享內存。</li><li>channel &amp; channels <code>有看沒懂ＴＢＤ</code></li><li><code>並行化</code>程式碼 注意不要混淆并发（concurrency）和并行（parallelism）的概念：并发是用可独立执行组件构造程序的方法， 而并行则是为了效率在多 CPU 上平行地进行计算。尽管 Go 的并发特性能够让某些问题更易构造成并行计算， 但 Go 仍然是种并发而非并行的语言，且 Go 的模型并不适合所有的并行问题。 关于其中区别的讨论，</li></ul></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goroutine-pool"></a>Goroutine Pool<a class="hash-link" href="#goroutine-pool" title="Direct link to heading">#</a></h2><ul><li>那些年我們追的 Goroutine Pool
<a href="https://medium.com/17media-tech/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E5%80%91%E8%BF%BD%E7%9A%84-goroutine-pool-e8d211757ee" target="_blank" rel="noopener noreferrer">https://medium.com/17media-tech/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E5%80%91%E8%BF%BD%E7%9A%84-goroutine-pool-e8d211757ee</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="與其他語言的比較"></a>與其他語言的比較<a class="hash-link" href="#與其他語言的比較" title="Direct link to heading">#</a></h2><ul><li><a href="https://www.gushiciku.cn/pl/gJKi/zh-tw" target="_blank" rel="noopener noreferrer">Go VS Java：一位資深程式設計師對兩種語言的解讀</a><ul><li>在Go中程序之間的通訊可以通過共享記憶體(並不推薦)和共享通道來完成。它允許開發者使用GoMaxProcs環境變數定義一個多核心的健壯且流暢有併發系統。</li><li>Go提供了一種特殊模式-race(競賽)來執行二進位制檔案，並同時檢查執行情況。通過此機制來證明軟體是併發安全的。</li></ul></li><li><a href="https://www.gushiciku.cn/dl/1psO4/zh-hk" target="_blank" rel="noopener noreferrer">Java 微服務能像 Go 一樣快嗎？</a><ul><li>在核心及內存容量更高的計算機上，Java 性能更好；在較小 / 性能較弱的計算機上，Go 性能更好。2020?</li></ul></li><li><a href="https://medium.com/cymetrics/javas-thread-model-and-golang-goroutine-46f8475600ae" target="_blank" rel="noopener noreferrer">Java’s Thread model and Golang Goroutine 比較</a><ul><li>實際上目前 Java 有個 Loom Project，就是要在 JVM 上實作類似 goroutine 機制的 virtual thread。</li></ul></li><li><a href="https://iter01.com/581149.html" target="_blank" rel="noopener noreferrer">Java微服務 vs Go微服務，究竟誰更強！？ 2020</a><ul><li>程式碼路徑非常短（只是操縱字串）</li><li>GO在2012年釋出了1.0版本（比JAVA晚了16年）</li><li>Java似乎比Go更善於使用所有可用的核心/執行緒—我們在Java測試中看到了更好的CPU利用率。Java效能在擁有更多核心和記憶體的機器上更好，Go效能在較小/功能較弱的機器上更好。在一臺“生產規模”的機器上，Java很容易就和Go一樣快，或者更快</li><li>源代碼 <a href="https://github.com/markxnelson/go-java-go" target="_blank" rel="noopener noreferrer">https://github.com/markxnelson/go-java-go</a></li></ul></li><li><a href="https://ithelp.ithome.com.tw/articles/10191148" target="_blank" rel="noopener noreferrer">Let&#x27;s Golang</a><ul><li>C/C++ 雖然快，但 Go 的開發效率比較高</li><li>有討論是說 Java 與 Go 的效能差不多， Go 的程式碼比較少，可維護性自然比較高</li></ul></li><li><a href="https://learnku.com/docs/the-way-to-go/go-performance-description/3580" target="_blank" rel="noopener noreferrer"> 3.8. Go 性能说明</a><ul><li>Go 语言与 C 语言的性能差距大概在 10%~20% (2013)</li><li>在最理想的情况下，Go 能够和 C++ 一样快，比 Scala 快 2 至 3 倍，比 Java 快 5 至 10 倍。(2011)</li><li>Go 的二进制文件体积是最大的（每个可执行文件都包含 runtime）。!!</li></ul></li><li><a href="http://blog.itpub.net/70001864/viewspace-2780863/" target="_blank" rel="noopener noreferrer">Go 与 C++ 的对比和比较</a><ul><li>Go isn’t magnitudes slower than C++ , 從內文看 除非追求極致才要用Ｃ</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="others"></a>others<a class="hash-link" href="#others" title="Direct link to heading">#</a></h2><ul><li><a href="https://s.weibo.com/weibo/%25E5%258D%2594%25E7%25A8%258B?topnav=1&amp;wvr=6&amp;b=1" target="_blank" rel="noopener noreferrer">微薄搜索</a></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/yumememooo/my-note/edit/master/docs/backend/golang/go_Gorountine.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-08-14T08:49:49.000Z" class="lastUpdatedDate_1WI_">8/14/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/my-note/docs/backend/golang/go_Continuous Profiling"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« [go] Continuous Profiling</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/my-note/docs/backend/golang/go_chan"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">[go] channel »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#多執行緒" class="table-of-contents__link">多執行緒</a></li><li><a href="#併發與平行" class="table-of-contents__link">併發與平行</a></li><li><a href="#線程與協程" class="table-of-contents__link">線程與協程</a><ul><li><a href="#非阻塞-io-模型-reactor" class="table-of-contents__link">非阻塞 I/O 模型 Reactor</a></li></ul></li><li><a href="#goroutine-是coroutine嗎？" class="table-of-contents__link">Goroutine 是coroutine嗎？</a></li><li><a href="#coroutine" class="table-of-contents__link">Coroutine</a><ul><li><a href="#所以？？" class="table-of-contents__link">所以？？</a></li></ul></li><li><a href="#影1-线程和协程的区别" class="table-of-contents__link">影1 线程和协程的区别</a></li><li><a href="#goroutine入门" class="table-of-contents__link">goroutine入门</a></li><li><a href="#channel-介紹" class="table-of-contents__link">channel 介紹</a><ul><li><a href="#issue" class="table-of-contents__link">issue</a></li></ul></li><li><a href="#data-race" class="table-of-contents__link">data race</a><ul><li><a href="#岩生" class="table-of-contents__link">岩生</a></li><li><a href="#go-worker-pool" class="table-of-contents__link">Go Worker Pool</a></li><li><a href="#關於到底什麼時候用鎖-go-鎖與channel選用？？" class="table-of-contents__link">關於到底什麼時候用鎖 go 鎖與channel選用??？？</a></li></ul></li><li><a href="#推薦-it邦幫忙教學文" class="table-of-contents__link">推薦 IT邦幫忙教學文</a></li><li><a href="#goroutine-調度模型" class="table-of-contents__link">goroutine 調度模型</a></li><li><a href="#可以用開的goroutines數量" class="table-of-contents__link">可以用開的goroutines數量</a></li><li><a href="#go-doc" class="table-of-contents__link">Go DOC</a><ul><li><a href="#effective_go" class="table-of-contents__link">effective_go</a></li></ul></li><li><a href="#goroutine-pool" class="table-of-contents__link">Goroutine Pool</a></li><li><a href="#與其他語言的比較" class="table-of-contents__link">與其他語言的比較</a></li><li><a href="#others" class="table-of-contents__link">others</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/my-note/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/my-note/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 YumeMemooo, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/my-note/assets/js/runtime~main.6c659791.js"></script>
<script src="/my-note/assets/js/main.216c6d34.js"></script>
</body>
</html>