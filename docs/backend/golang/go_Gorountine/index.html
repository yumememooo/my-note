<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/my-note/blog/rss.xml" title="YumeMemooo's Note Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/my-note/blog/atom.xml" title="YumeMemooo's Note Blog Atom Feed"><title data-react-helmet="true">Gorountine | YumeMemooo&#x27;s Note</title><meta data-react-helmet="true" property="og:url" content="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Gorountine | YumeMemooo&#x27;s Note"><meta data-react-helmet="true" name="description" content="一種golang的協程？"><meta data-react-helmet="true" property="og:description" content="一種golang的協程？"><link data-react-helmet="true" rel="shortcut icon" href="/my-note/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine"><link data-react-helmet="true" rel="alternate" href="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://yumememooo.github.io/my-note/docs/backend/golang/go_Gorountine" hreflang="x-default"><link rel="stylesheet" href="/my-note/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/my-note/assets/js/runtime~main.b3d6ffaa.js" as="script">
<link rel="preload" href="/my-note/assets/js/main.099611d7.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><div class="announcementBar_3WsW" style="background-color:#82e675;color:#050505" role="banner"><div class="announcementBarContent_3EUC">☞這裡是暫存的隨筆草稿區，另有建立整理後的文章可以進入☆主網站 <a target="_blank" rel="noopener noreferrer" href="https://yumememooo.github.io/" ☆> yumememooo</a>☆</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-note/"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">YumeMemooo&#x27;s Note</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/my-note/docs/intro">All Notes</a><a class="navbar__item navbar__link" href="/my-note/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">My Github</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link">Community</a><ul class="dropdown__menu"><li><a href="https://yumememooo.github.io/about/" target="_blank" rel="noopener noreferrer" class="dropdown__link">About Me</a></li><li><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="dropdown__link">GitHub</a></li></ul></div><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/my-note/"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/my-note/img/logo.svg" alt="My Note Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">YumeMemooo&#x27;s Note</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/my-note/docs/intro">All Notes</a></li><li class="menu__list-item"><a class="menu__link" href="/my-note/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="menu__link">My Github</a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">Community</a><ul class="menu__list"><li class="menu__list-item"><a href="https://yumememooo.github.io/about/" target="_blank" rel="noopener noreferrer" class="menu__link">About Me</a></li><li class="menu__list-item"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/my-note/docs/intro">關於 YumeMemooo&#x27;s Note</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Docusaurus</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/intro">Tutorial Intro</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Tutorial - Basics</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/create-a-page">Create a Page</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/create-a-document">Create a Document</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/create-a-blog-post">Create a Blog Post</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/markdown-features">Markdown Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/deploy-your-site">Deploy your site</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-basics/congratulations">Congratulations!</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Tutorial - Extras</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-extras/manage-docs-versions">Manage Docs Versions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/docusaurus/tutorial-extras/translate-your-site">Translate your site</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">frontend</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">desing</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/design/design_pixel">像素與解析度</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">all</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/all/http-cors">[web] 跨域請求 CORS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/all/react-hook-learn">網路文章 react hook系列文學習筆記</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">best_pratice</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/best_pratice/google">Google I/O 2021 </a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/best_pratice/html_a_ref">[安全性]為什麼超連結要使用noreferrer noopener</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/frontend/best_pratice/js">JS更好的寫法</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">backend</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">golang</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_ why">golang介紹與優勢</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_ little_thing">golang的那些小事</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_ asleep">all goroutines are asleep</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_Continuous Profiling">[go] Continuous Profiling</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/my-note/docs/backend/golang/go_Gorountine">Gorountine</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_map">GOLANG的MAP的併發問題</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_pprof">[go] pprof</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_struct">[go] struct &amp; tag</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_switch">[go] switch</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/my-note/docs/backend/golang/go_trace">[go] trace</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">others</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/backend/others/linux_command">[command]linux 歷史紀錄</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/backend/others/number_bit">位元與數字</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/backend/others/startedTime">程式的啟動速度</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">tool</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/git">[node]npx</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/node">[git] 上傳程式碼操作</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/open_ material">[material] 網路上素材與線上工具</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/my-note/docs/tool/mac">mac</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Gorountine</h1></header><div class="markdown"><p>一種golang的協程？</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多執行緒"></a>多執行緒<a class="hash-link" href="#多執行緒" title="Direct link to heading">#</a></h2><ul><li>[電腦的核心 (Core) 和執行緒 (Tread)](<a href="https://jenifers001d.github.io/2020/08/04/%E9%9B%BB%E8%85%A6%E7%9F%A5%E8%AD%98/what-is-core-and-thread/" target="_blank" rel="noopener noreferrer">https://jenifers001d.github.io/2020/08/04/%E9%9B%BB%E8%85%A6%E7%9F%A5%E8%AD%98/what-is-core-and-thread/</a></li><li>淺談多核CPU、多執行緒與平行計算](<a href="https://www.itread01.com/content/1549608874.html" target="_blank" rel="noopener noreferrer">https://www.itread01.com/content/1549608874.html</a><ul><li>多執行緒的作用不只是用作平行計算</li><li>阻塞在什麼時候發生呢？一般是等待IO操作（磁碟，資料庫，網路等等）。</li><li>在單核時代，多執行緒的這個消除阻塞的作用還可以叫做“併發”，這和並行是有著本質的不同的。併發是“偽並行”，看似並行，而實際上還是一個CPU在執行一切事物，只是切換的太快，我們沒法察覺罷了。</li><li>四種場景？？不懂</li></ul></li><li><a href="https://www.itread01.com/content/1544961004.html" target="_blank" rel="noopener noreferrer">對於多執行緒程式，單核cpu與多核cpu是怎麼工作的</a><ul><li>多執行緒在單cpu中其實也是順序執行的，，不過系統可以幫你切換那個執行而已，效率不會有提高的≤切換執行緒反倒會增加開銷</li><li><code>多執行緒的用處在於，做某個耗時的操作時，需要等待返回結果，這時用多執行緒可以提高程式併發程度</code>。如果一個不需要任何等待並且順序執行能夠完成的任務，用多執行緒簡直是浪費。</li><li>什麼時候該使用多執行緒呢？這要分四種情況討論：？？不懂</li></ul></li><li><a href="https://medium.com/erens-tech-book/%E7%90%86%E8%A7%A3-process-thread-94a40721b492" target="_blank" rel="noopener noreferrer">【恐龍】理解 Process &amp; Thread</a><ul><li>併發不一定要在同一時刻？並發未必平行</li></ul></li><li><a href="https://www.gushiciku.cn/pl/pcJA/zh-tw" target="_blank" rel="noopener noreferrer">15分鐘讀懂程序執行緒、同步非同步、阻塞非阻塞、併發並行，太實用了！</a><ul><li>多執行緒：火車站開n個視窗</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="併發與平行"></a>併發與平行<a class="hash-link" href="#併發與平行" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10242047" target="_blank" rel="noopener noreferrer">ＩＴ邦 程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a></p><ul><li>程arallel 並行是利用多個 CPU 達到同時並行處理任務的需求（也就是同一個時間點有許多任務在同時執行）</li><li>Concurrent 則是許多任務在爭搶同一個 CPU 的資源，因此一個時間點只會有一個任務正在執行，只是因為切換非常快，使用者通常不會感覺到任務實際上一直在切換。 (單核是，但多核怪怪的 併發不一定要在同一時刻？並發未必平行)
<img src="https://miro.medium.com/max/1108/1*7GZrAWoGc_nZtuvHIJ9w-w.jpeg"></li></ul></li><li><p><a href="https://hsinyu.gitbooks.io/golang_note/content/goroutine.html" target="_blank" rel="noopener noreferrer">goroutine個人筆記 concurrency (併發) vs parallelism (並行)</a>覺得process圖這篇怪怪的</p><ul><li><code>M:N圖</code></li></ul></li><li><p><a href="https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism" target="_blank" rel="noopener noreferrer">Concurrency-vs-Parallelism</a> </p><ul><li>這圖畫得比較好</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="線程與協程"></a>線程與協程<a class="hash-link" href="#線程與協程" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10242047" target="_blank" rel="noopener noreferrer">ＩＴ邦 程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a></p><ul><li>MultiProcessing 多進程 &amp; MultiThreadingf 多線程</li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10239629" target="_blank" rel="noopener noreferrer">Day 18 | Kotlin 中處理異步的好伙伴 - Coroutine</a></p><ul><li>程式（Application ）&gt;進程（ Process ）&gt;線程/執行緒（ Thread ) &gt;協程（ Coroutine ） </li><li>Process 之間是不能直接溝通的（如果可以任意呼叫到其他應用程式裏面的內容，那也有點太可怕了）</li><li>Thread 共享資源</li><li>協程（ Coroutine ） ： Coroutine 一次只會執行一個 Job ，會透過頻繁切換 Job 達到類似異步的效果，需要的資源比開新的 Thread 少  <code>圖</code></li></ul></li></ul><ul><li><a href="https://ithelp.ithome.com.tw/articles/10219673" target="_blank" rel="noopener noreferrer">30-08 之應用層的 I/O 優化 ( 維護性 ) - 協程 Coroutine</a><ul><li>coroutine 協程:在應用層實現同步非阻塞的 I/O 操作</li><li>異步非阻塞寫法:callback hell-&gt;同步非阻塞寫法(在 nodejs 中的 async/await 就是協程)</li><li>coroutine 協程實現原理:應用端內部會『 自行 』的決定誰先執行</li><li>關於 Coroutine 的幾個問題:coroutine是性能的減項,此應用已是一個異步非阻塞的應用，當你搭配 coroutine 下去，會減少不少的維護成本，因為寫法就和一般程式寫法一樣。</li><li><code>Golang 的 Goroutine?-&gt; 是coroutine嗎？</code>一半算，goroutine 有實現 corotuine 想完成的『同步』這個事情，但同時間它又針對 cpu 運算這方面在實現上增加不少改善</li><li>Golang 的運行架構:Sched+MPG 模型,goroutine 在運行時阻塞了會自動的分配到閒的 thread</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="非阻塞-io-模型-reactor"></a>非阻塞 I/O 模型 Reactor<a class="hash-link" href="#非阻塞-io-模型-reactor" title="Direct link to heading">#</a></h3><ul><li><a href="https://ithelp.ithome.com.tw/articles/10219203" target="_blank" rel="noopener noreferrer">30-07 之應用層的 I/O 優化 - 非阻塞 I/O 模型 Reactor</a>
當系統 I/O 操作繁重時，請使用 refactor 模式的支援語言或是框架。
當系統 CPU 運算繁重時，則使用 multi process 的模式。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goroutine-是coroutine嗎？"></a>Goroutine 是coroutine嗎？<a class="hash-link" href="#goroutine-是coroutine嗎？" title="Direct link to heading">#</a></h2><ul><li>上面說一半算</li><li><a href="http://c.biancheng.net/view/96.html" target="_blank" rel="noopener noreferrer">goroutine和coroutine的区别</a><ul><li><code>goroutine 可能发生并行执行</code>；但 coroutine 始终顺序执行。</li><li>goroutines 通过通道来通信；coroutines 通过让出和恢复操作来通信 (goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。)</li><li>goroutines 比 coroutines 更强大</li><li>goroutine 可能发生在多线程环境下，goroutine 无法控制自己获取高优先度支持；coroutine 始终发生在单线程，coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine。</li><li>coroutine 的运行机制属于协作式任务处理，如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力</li><li>goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</li></ul></li><li><a href="https://stackoverflow.com/questions/18058164/is-a-go-goroutine-a-coroutine" target="_blank" rel="noopener noreferrer">Go goroutine 是協程嗎？stackoverflow</a></li><li><a href="https://www.huaweicloud.com/articles/949bec4beeb84dfcaea30513b3d497c8.html" target="_blank" rel="noopener noreferrer">python协程与golang协程精讲</a><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- Python的协程源于yield指令</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- Go实现了两种并发形式:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    - 多线程共享内存。如Java或者C++等在多线程中共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    - Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。Go的CSP并发模型实现M, P, G : </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- go的协程本质上还是系统的线程调用，而Python中的协程是eventloop模型实现，所以虽然都叫协程,Python 中的协程是严格的 1:N 关系一个线程对应了多个协程。虽然可以实现异步I/O，但是不能有效利用多核</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- 而 Go 中是 M:N 的关系也就是 N 个协程会映射分配到 M 个线程上多个线程能分配到不同核心上,CPU 密集的应用使用 goroutine 也会获得加速.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div>即使有少量阻塞的操作，也只会阻塞某个 worker 线程，而不会把整个程序阻塞<div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- goroutine 中不需要显式使用 await 交出控制权，但是 Go 也不会严格按照时间片去调度 goroutine，而是会在可能阻塞的地方插入调度。goroutine 的调度可以看做是半抢占式的。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="所以？？"></a>所以？？<a class="hash-link" href="#所以？？" title="Direct link to heading">#</a></h3><ul><li><a href="https://codychen.me/2019/12/%E5%A4%9A%E9%80%B2%E7%A8%8B/%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92-%E4%B8%A6%E7%99%BC/%E5%B9%B3%E8%A1%8C/" target="_blank" rel="noopener noreferrer">多進程/多執行緒！ 並發/平行？</a> 看完更不懂了</li></ul><p>Ｑ多核多執行緒是否就是平行處理？
Ｑ：多核下的併發是否可以是一些平行處理一些併發處理？？</p><ul><li><a href="https://www.gushiciku.cn/pl/2P2w/zh-tw" target="_blank" rel="noopener noreferrer">Go FAQ 問題</a></li></ul><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="影1-线程和协程的区别"></a>影1 线程和协程的区别<a class="hash-link" href="#影1-线程和协程的区别" title="Direct link to heading">#</a></h2><p>1.（影）为什么golang能够脱颖而出？线程和协程的区别是什么？</p><p>1.1 線程是跟硬件相關的 會消耗佔用ＣＰＵ 內存等等
線程是軟件的概念 像是函數 method？ 類似是消息的隊列</p><p>1.2 創建goruntine的開銷是比較小的 速度也快很多
可以創建一百萬兩百萬的協程沒有問題
但就做不到創建一百萬兩百萬個線程了 慢且ＣＰＵ沒有這麼多core，內存被消耗得很厲害</p><p>1.3 線程都有一個唯一的ＩＤ來標示，“Goroutine沒有？”</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="延伸閱讀：為什麼沒有goroutine-id"></a>延伸閱讀：為什麼沒有Goroutine ID<a class="hash-link" href="#延伸閱讀：為什麼沒有goroutine-id" title="Direct link to heading">#</a></h4><ul><li><a href="https://www.gushiciku.cn/pl/gYQQ/zh-hk" target="_blank" rel="noopener noreferrer">Go 羣友提問：進程、線程都有 ID，為什麼 Goroutine 沒有 ID？</a></li><li>在常規的進程、線程中都有其 ID 的概念，我們可以在程序中通過 ID 來獲取其他進程、線程中的數據，甚至是傳輸數據。就像一把鑰匙一樣，有了他幹啥都可以。</li><li>Go 語言在以前是有暴露方法去獲取 GoroutineID 的，但在 Go1.4 後就把該方法給隱藏起來了，不建議大家使用。假設可以通過 GoroutineID 進行跨協程操縱，那麼就有可能出現我的 Goroutine，不一定是由 “我” 自己決定的。可能其他正在處理的 GoroutineB 悄悄摸摸的改了我這個 GoroutineA 的行為。
這就有可能導致一個災難問題</li><li>其實還是可以寫程式去拿到Goroutine ID的，而去排查 Go 工程中的問題，例如：錯誤堆棧信息、PProf 性能分析等調試信息也可以看到。</li></ul><p>1.4 通信方式
線程適用全局變量還要加鎖保證數據沒有,,,
協程使用channel</p><hr><p>看起來同步的方式去寫出異步 非阻塞式掛起
併發 多線程</p><hr><p><code>不太懂</code></p><p><a href="https://www.youtube.com/watch?v=uJXSMMyvAgM" target="_blank" rel="noopener noreferrer">沈崴 - 为什么协程是真并行而线程不是</a>
攜程也是可以多核
協程可以控制上下文 把邏輯切換點作為調度點?
協程是真並行?</p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goroutine入门"></a>goroutine入门<a class="hash-link" href="#goroutine入门" title="Direct link to heading">#</a></h2><ul><li><a href="https://www.cnblogs.com/sparkdev/p/10930168.html" target="_blank" rel="noopener noreferrer">Golang 入门 : goroutine(协程)</a><ul><li>要在一个协程中运行函数，直接在调用函数时添加关键字 go 就可以了</li><li>协程也叫轻量级的线程，与传统的进程和线程相比，协程的最大特点是 &quot;轻&quot;！可以轻松创建上百万个协程而不会导致系统资源衰竭。</li><li>多数编程语言在语法层面并不直接支持协程，而是通过库的方式支持。但是用库的方式支持的功能往往不是很完整，比如仅仅提供轻量级线程的创建、销毁和切换等能力。如果在这样的协程中调用一个同步 IO 操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行的协程，从而无法达到轻量级线程本身期望达到的目标。</li><li>Golang 在语言级别支持协程，称之为 goroutine。Golang 标准库提供的所有系统调用操作(包括所有的同步 IO 操作)，都会出让 CPU 给其他 goroutine。这让 goroutine 的切换管理不依赖于系统的线程和进程，也不依赖于 CPU 的核心数量，而是交给 Golang 的运行时统一调度。</li></ul></li><li><a href="https://www.educative.io/edpresso/what-are-channels-in-golang" target="_blank" rel="noopener noreferrer">What are channels in Golang?</a>     <code>可愛的通道圖</code></li><li><a href="https://zhuanlan.zhihu.com/p/74047342" target="_blank" rel="noopener noreferrer">Golang协程详解和应用</a><ul><li>并发还并行? 程式碼</li><li>如果当前CPU是单核，那么上面程序就是并发执行，如果当前CPU是多核，那就是并行执行，结果都是一样的-&gt;说明单核CPU只能并发，不能并行</li></ul></li></ul><p>demoe:<a href="https://play.golang.org/p/ZR_Y6ugAgfW" target="_blank" rel="noopener noreferrer">https://play.golang.org/p/ZR_Y6ugAgfW</a></p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="it邦幫忙教學文"></a>IT邦幫忙教學文<a class="hash-link" href="#it邦幫忙教學文" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://ithelp.ithome.com.tw/articles/10240892" target="_blank" rel="noopener noreferrer"># Day14 Go併發症狀- Goroutines (go)</a></p><ul><li>併發(Concurrency)是共享時間運算，在一段時間內輪流享有時間資源 ，是把時間切成很小很小段，在這小段的時間裡先後執行多項任務。一個人在一段時間內做兩件事</li><li>併行(Parallelism)是平行運算，一直都能享有時間資源,是CPU有多個核心，可以同時處理多個任務。,兩個人同時在做事</li><li>Go併發（Goroutines）是輕量級的線程。</li><li>入門使用及限制一個ＣＰＵ核心runtime.GOMAXPROCS(1)時, Goroutine 仍可以切換．</li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10212068?sc=pt" target="_blank" rel="noopener noreferrer">Go 的並發：Goroutine 與 Channel 介紹</a></p><ul><li>介紹單執行緒與多執行緒下Goroutine 的圖示</li><li>互斥與channel</li><li><code>TBD Q</code></li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10218923" target="_blank" rel="noopener noreferrer">Channel, goroutine之間的溝通橋樑</a></p><ul><li>Channel就像是一個輸送帶, 遵守著FIFO的規則, 保證收發資料的順序.</li><li>多個goroutine為了搶奪存取資料, 勢必造成執行效率的低下, 使用queue是一種高效率的同步存取方式, channel就是一種queue一樣的結構.</li><li>channel 宣告介紹 ＋ <code>緩衝與無緩衝 圖</code>·</li><li>發送資料量必須在消費方處理量+通道長度的範圍內, 才能正確的處理</li><li>不要透過共享變數+Mutex來進行操作, 應該透過channel來共享</li><li>對channel的操作行為整理 close slect&amp; 發布端跟訂閱端這裡的使用場景....</li><li><code>TBD Q</code></li></ul></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10218483" target="_blank" rel="noopener noreferrer">Goroutine 讓你用少少的線程, 能接受更多的工作, 但沒說會作比較快</a></p><ul><li>一個goroutine大小大概2kb-4kb, 非常的小, 所以要管理個上千上萬個goroutine是相對於其他語言, 比較不佔記憶體的.</li><li>Go的併發同步模型是採用CSP(Communicating Sequential Process), 是一種訊息傳遞模式, 不是透過對資料加上lock來做同步存取, 而是透過CSP在goroutine之間傳遞訊息, channel在多個goroutine之間進行同步通信與交換.</li><li>單核的情形下, Goroutine跟 NodeJS的EventLoop(1:m映射)很相似.</li><li>多核心多線程, goroutine會生成多個邏輯處理器在調度器間處理, 每個上會有很多goroutines (n:m映射). </li><li>Concurrency 圖 滿足Go跟Node的設計哲學, &quot;用較少的資源作更多的事情&quot;. ＋ Parallelism goroutine在不同的系統線程M上執行.但如果要實現平行, 需要自己讓代碼執行在有多個物理cpu上. （<code>重要</code>）</li><li><code>TBD Q</code></li></ul></li></ul><ul><li>[Day09] 進程、線程、協程，傻傻分得清楚！](<a href="https://ithelp.ithome.com.tw/articles/10242047" target="_blank" rel="noopener noreferrer">https://ithelp.ithome.com.tw/articles/10242047</a>)<ul><li><code>圖 Concurrent &amp; Parallel + 圖  進程、線程、協程</code></li><li>名詞對照</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goroutine-調度模型"></a>goroutine 調度模型<a class="hash-link" href="#goroutine-調度模型" title="Direct link to heading">#</a></h2><ul><li><a href="https://www.readfog.com/a/1634446830986170368" target="_blank" rel="noopener noreferrer">探究 goroutine 併發調度模型</a><ul><li>官方宣稱原生 goroutine 併發成千上萬不成問題。實現併發編程，goroutine 具有消耗資源低、運行效率高等特點</li><li>Go 調度器需要將衆多 goroutine 按照一定的算法調度到操作系統的線程上執行。這種在語言層面自帶調度器的，稱之爲原生支持併發。</li><li>操作系統會爲每個線程分配固定大小（一般是 2MB）的內存塊做棧。線程在內核切換上下文是很慢的。</li><li><code>動態棧</code>:goroutine 的棧不是固定的，一開始以一個很小的棧空間（2KB）開啓生命週期，棧的大小會根據需要動態伸縮。</li><li><code>調度器的切換成本</code>Go 調度器是在其本身運行的用戶層進行調度的，不需要進入內核的上下文切換，調度成本會低很多。</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/60613088" target="_blank" rel="noopener noreferrer">Go goroutine理解</a><ul><li>Goroutine和其他语言的协程（coroutine）在使用方式上类似， 因此Goroutine可以理解为一种Go语言的协程。同时它可以运行在一个或多个线程上。</li><li>Go实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是Java或者C++等语言中的多线程开发。另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</li><li>GO并发模型的实现原理 <code>TBD hard</code>  M:N的圖</li><li>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（goroutine：2KB ，线程：8MB）</li><li>Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。缺点：协程调度机制无法实现公平调度。</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/80853548" target="_blank" rel="noopener noreferrer">深度解密Go语言之 scheduler</a><ul><li><code>M:N 模型</code>:Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。这就是 M:N 模型：向一个 channel 发送数据，被阻塞）时，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。目的就是不让一个线程闲着，榨干 CPU 的每一滴油水。</li><li>限制同时运行（不包含阻塞）的线程数为 N，N 等于 CPU 的核心数目；</li><li>scheduler 的陷阱:于 Go 语言中运行时间过长的 goroutine，Go scheduler 有一个后台线程在持续监控，一旦发现 goroutine 运行超过 10 ms，会设置 goroutine 的“抢占标志位”</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="可以用開的goroutines數量"></a>可以用開的goroutines數量<a class="hash-link" href="#可以用開的goroutines數量" title="Direct link to heading">#</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/162668146" target="_blank" rel="noopener noreferrer">为什么 Go 允许百万级别的 goroutines，而 Java 只允许数千级别的 threads?</a><ul><li><code>Thread</code> CPUs 中的每一个 Core 在同一时刻只能真正并发执行一个 logic thread[1]。这就产生了一个结论：如果你的 threads 个数大于 CPU 的 Core 个数的话，有一部分的 Threads 就必须要暂停来让其他 Threads 工作，</li><li>使用操作系统层面的 thread，每一个 thread 都需要耗费静态的大量的内存,果使用1MB的栈默认值，那么创建1000个 threads ，将使用 1GB 的 RAM ，虽然 RAM 现在很便宜，但是如果要创建一亿个 threads ，就需要T级别的内存。</li><li>新建的一个 Goroutine 实际只占用 4KB 的栈空间。一个栈只占用 4KB，1GB 的内存可以创建 250 万个 Goroutine，相对于 Java 一个栈占用 1MB 的内存，这的确是一个很大的提高。</li><li>在 JVM 中上下文的切换是很慢的<ul><li>评论: go的百万goroutine调度慢到吓人，内存占用也高到恐怖.而真正实现百万级调度还基本可用的是C#的task</li><li>为啥C#支持无上限的协程，而Go只支持百万级？一个脑子正常的java程序员不可能开上千个thread</li></ul></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="data-race"></a>data race<a class="hash-link" href="#data-race" title="Direct link to heading">#</a></h2><ul><li><a href="https://segmentfault.com/a/1190000018719287" target="_blank" rel="noopener noreferrer">15 Go语言并发1——Goroutine</a><ul><li>Go 調度器</li><li>简单使用waitgroup同步</li><li>如何解决资源竞争和线程同步，这就有两类，一类是传统的方式——加锁，另一类是go语言有的通过chanel,采用<code>csp模型，即通过通信去共享内存，而不是通过共享内存而通信。</code></li><li><code>原子函数atomic</code> 然可以解决资源竞争问题，但是比较都是比较简单的，支持的数据类型也有限。所以，sync 提供了互斥锁来解决</li><li>sync包里提供了一种互斥型的锁，可以让我们自己灵活的控制哪些代码，同时只能有一个goroutine访问，被sync互斥锁控制的这段代码范围，被称之为临界区，临界区的代码，同一时间，只能有一个goroutine访问。代码如下</li><li><code>读写锁</code>:goroutine进行写操作的时候，其他goroutine既不能进行读操作，也不能进行写操作。</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="coroutine"></a>Coroutine<a class="hash-link" href="#coroutine" title="Direct link to heading">#</a></h2><p>這邊是講傳統的協程用法 yield</p><ul><li><a href="https://electronic.blue/blog/2012/06/11-coroutine-an-introduction/" target="_blank" rel="noopener noreferrer">Coroutine: 入門篇</a></li><li><a href="https://mp.weixin.qq.com/s/6sN2hdxCNWiDfizWdzS2yA" target="_blank" rel="noopener noreferrer">如何编写 C++ 20 协程(Coroutines)</a><ul><li>C++协程就是一个可以挂起(suspend)和恢复(resume)的函数(</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="go-worker-pool"></a>Go Worker Pool<a class="hash-link" href="#go-worker-pool" title="Direct link to heading">#</a></h2><p>有一種寫法是可以開多個接收端進行處理，<code>但效能如何看？？ TBD</code> </p><ul><li><a href="https://www.coder.work/article/1027330" target="_blank" rel="noopener noreferrer">concurrency - Go Worker Pool似乎没有同时处理</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="go-doc"></a>Go DOC<a class="hash-link" href="#go-doc" title="Direct link to heading">#</a></h2><ul><li>effective_go](<a href="https://golang.org/doc/effective_go" target="_blank" rel="noopener noreferrer">https://golang.org/doc/effective_go</a>)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="effective_go"></a>effective_go<a class="hash-link" href="#effective_go" title="Direct link to heading">#</a></h3><p>高效的 Go 编程 中文翻譯</p><ul><li><a href="https://learnku.com/docs/effective-go/2020/concurrent/6249" target="_blank" rel="noopener noreferrer">高效的 Go 编程</a><ul><li>併發<ul><li><code>Share by communicating</code>:不要通過共享內存來通信，而應通過通信來共享內存。</li><li>channel &amp; channels <code>有看沒懂ＴＢＤ</code></li><li><code>並行化</code>程式碼 注意不要混淆并发（concurrency）和并行（parallelism）的概念：并发是用可独立执行组件构造程序的方法， 而并行则是为了效率在多 CPU 上平行地进行计算。尽管 Go 的并发特性能够让某些问题更易构造成并行计算， 但 Go 仍然是种并发而非并行的语言，且 Go 的模型并不适合所有的并行问题。 关于其中区别的讨论，</li></ul></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="others"></a>others<a class="hash-link" href="#others" title="Direct link to heading">#</a></h2><ul><li><a href="https://s.weibo.com/weibo/%25E5%258D%2594%25E7%25A8%258B?topnav=1&amp;wvr=6&amp;b=1" target="_blank" rel="noopener noreferrer">微薄搜索</a></li><li><a href="https://www.gushiciku.cn/pl/gJKi/zh-tw" target="_blank" rel="noopener noreferrer">Go VS Java：一位資深程式設計師對兩種語言的解讀</a><ul><li>在Go中程序之間的通訊可以通過共享記憶體(並不推薦)和共享通道來完成。它允許開發者使用GoMaxProcs環境變數定義一個多核心的健壯且流暢有併發系統。</li><li>Go提供了一種特殊模式-race(競賽)來執行二進位制檔案，並同時檢查執行情況。通過此機制來證明軟體是併發安全的。</li></ul></li><li><a href="https://www.gushiciku.cn/dl/1psO4/zh-hk" target="_blank" rel="noopener noreferrer">Java 微服務能像 Go 一樣快嗎？</a><ul><li>在核心及內存容量更高的計算機上，Java 性能更好；在較小 / 性能較弱的計算機上，Go 性能更好。2020?</li></ul></li><li><a href="https://medium.com/cymetrics/javas-thread-model-and-golang-goroutine-46f8475600ae" target="_blank" rel="noopener noreferrer">Java’s Thread model and Golang Goroutine 比較</a><ul><li>實際上目前 Java 有個 Loom Project，就是要在 JVM 上實作類似 goroutine 機制的 virtual thread。</li></ul></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/yumememooo/my-note/edit/master/docs/backend/golang/go_Gorountine.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/my-note/docs/backend/golang/go_Continuous Profiling"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« [go] Continuous Profiling</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/my-note/docs/backend/golang/go_map"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">GOLANG的MAP的併發問題 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#多執行緒" class="table-of-contents__link">多執行緒</a></li><li><a href="#併發與平行" class="table-of-contents__link">併發與平行</a></li><li><a href="#線程與協程" class="table-of-contents__link">線程與協程</a><ul><li><a href="#非阻塞-io-模型-reactor" class="table-of-contents__link">非阻塞 I/O 模型 Reactor</a></li></ul></li><li><a href="#goroutine-是coroutine嗎？" class="table-of-contents__link">Goroutine 是coroutine嗎？</a><ul><li><a href="#所以？？" class="table-of-contents__link">所以？？</a></li></ul></li><li><a href="#影1-线程和协程的区别" class="table-of-contents__link">影1 线程和协程的区别</a></li><li><a href="#goroutine入门" class="table-of-contents__link">goroutine入门</a></li><li><a href="#it邦幫忙教學文" class="table-of-contents__link">IT邦幫忙教學文</a></li><li><a href="#goroutine-調度模型" class="table-of-contents__link">goroutine 調度模型</a></li><li><a href="#可以用開的goroutines數量" class="table-of-contents__link">可以用開的goroutines數量</a></li><li><a href="#data-race" class="table-of-contents__link">data race</a></li><li><a href="#coroutine" class="table-of-contents__link">Coroutine</a></li><li><a href="#go-worker-pool" class="table-of-contents__link">Go Worker Pool</a></li><li><a href="#go-doc" class="table-of-contents__link">Go DOC</a><ul><li><a href="#effective_go" class="table-of-contents__link">effective_go</a></li></ul></li><li><a href="#others" class="table-of-contents__link">others</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/my-note/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/my-note/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/yumememooo" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 YumeMemooo, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/my-note/assets/js/runtime~main.b3d6ffaa.js"></script>
<script src="/my-note/assets/js/main.099611d7.js"></script>
</body>
</html>